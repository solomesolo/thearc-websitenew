import { KeyMetricResult, WeeklyAction, SurveyAnswers, NarrativeBlocks, TrajectoryPoint } from './types';
import { PatternSummary, derivePatternSummary } from './patterns';
import { generateTrajectory } from './trajectory';
import { buildMenopauseNarrativePrompt } from './narrativePrompt';
import { getMenopauseTags } from './mappings';
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Convert key metrics to band-only format (no scores)
 */
function keyMetricsToBands(keyMetrics: KeyMetricResult[]): Record<string, string> {
  const bands: Record<string, string> = {};
  keyMetrics.forEach(metric => {
    bands[metric.id] = metric.band;
  });
  return bands;
}

/**
 * Convert weekly actions to plan pillars (topics only, no raw answers)
 */
function weeklyActionsToPillars(weeklyActions: WeeklyAction[]): Array<{ category: string; bulletThemes: string[] }> {
  return weeklyActions.map(action => ({
    category: action.title,
    bulletThemes: action.bullets.map(bullet => {
      // Extract theme from bullet (remove any specific details)
      // This is a simple extraction - in production you might want more sophisticated parsing
      return bullet.split(':')[0] || bullet.split('.')[0] || bullet;
    }),
  }));
}

/**
 * Call OpenAI to generate narrative JSON
 */
async function callLLMForJson(prompt: string): Promise<any> {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "You are a clinical wellness education writer. Always output valid JSON only, no markdown formatting.",
        },
        {
          role: "user",
          content: prompt,
        },
      ],
      response_format: { type: "json_object" },
      temperature: 0.7,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error("No content in OpenAI response");
    }

    return JSON.parse(content);
  } catch (error) {
    console.error("Error calling OpenAI for narrative:", error);
    throw error;
  }
}

/**
 * Validate and structure narrative JSON response
 */
function validateNarrative(json: any, trajectoryPoints: TrajectoryPoint[]): NarrativeBlocks {
  // Validate structure
  if (!json.whereYouAreNow || !json.yourPersonalPlan) {
    throw new Error("Invalid narrative structure from LLM");
  }

  // Use provided trajectory points (either LLM-generated or deterministic fallback)
  return {
    whereYouAreNow: {
      headline: json.whereYouAreNow.headline || "Understanding Your Current Patterns",
      body: json.whereYouAreNow.body || "",
      patternSummaryBullets: Array.isArray(json.whereYouAreNow.patternSummaryBullets)
        ? json.whereYouAreNow.patternSummaryBullets
        : [],
    },
    yourPersonalPlan: {
      headline: json.yourPersonalPlan.headline || "Your Personalized Plan",
      body: json.yourPersonalPlan.body || "",
      planPillars: Array.isArray(json.yourPersonalPlan.planPillars)
        ? json.yourPersonalPlan.planPillars
        : [],
    },
    trajectory: trajectoryPoints, // Use provided trajectory (LLM-generated if available, otherwise deterministic)
  };
}

/**
 * Main function to build narrative blocks
 */
export async function buildNarrativeBlocks(params: {
  keyMetrics: KeyMetricResult[];
  weeklyActions: WeeklyAction[];
  surveyAnswers: SurveyAnswers;
}): Promise<NarrativeBlocks> {
  // Step 1: Derive pattern summary
  const patternSummary = derivePatternSummary(
    params.keyMetrics,
    params.weeklyActions,
    params.surveyAnswers
  );

  // Step 2: Generate deterministic trajectory
  const trajectoryPoints = generateTrajectory(
    params.keyMetrics,
    patternSummary,
    params.weeklyActions
  );

  // Step 3: Build plan pillars
  const planPillars = weeklyActionsToPillars(params.weeklyActions);

  // Step 4: Get metric bands (no scores)
  const metricBands = keyMetricsToBands(params.keyMetrics);

  // Step 5: Get menopause tags
  const menopauseTags = getMenopauseTags(params.surveyAnswers);

  // Step 6: Build prompt
  const prompt = buildMenopauseNarrativePrompt({
    menopauseTags,
    metricBands,
    patterns: patternSummary.tags.map(t => ({
      tag: t,
      severity: patternSummary.severity[t] ?? 0,
    })),
    dominantDomains: patternSummary.dominantDomains,
    planPillars,
  });

  // Step 7: Call LLM
  let narrativeJson;
  try {
    narrativeJson = await callLLMForJson(prompt);
    
    // Validate that trajectory was generated by LLM
    if (!narrativeJson.trajectory || !Array.isArray(narrativeJson.trajectory) || narrativeJson.trajectory.length !== 8) {
      console.warn("LLM did not generate complete trajectory, using deterministic trajectory");
      // Will use deterministic trajectory as fallback
    }
  } catch (error) {
    console.error("Failed to generate narrative from LLM, using fallback:", error);
    // Fallback to basic structure if LLM fails
    narrativeJson = {
      whereYouAreNow: {
        headline: "Understanding Your Current Patterns",
        body: "Based on your responses, we've identified several interconnected patterns affecting your health during this transition.",
        patternSummaryBullets: patternSummary.tags.slice(0, 5).map(t => `Pattern: ${t.replace(/_/g, " ")}`),
      },
      yourPersonalPlan: {
        headline: "Your Personalized Plan",
        body: "Your plan is designed to address the key areas where support can make the most difference.",
        planPillars: planPillars.map(p => ({ title: p.category, description: `Focus on ${p.category.toLowerCase()} interventions` })),
      },
      trajectory: [],
    };
  }

  // Step 8: Validate and return
  // Use LLM-generated trajectory if available and valid (8 points for 4 horizons x 2 lanes), otherwise use deterministic
  const finalTrajectory = (narrativeJson.trajectory && 
                           Array.isArray(narrativeJson.trajectory) && 
                           narrativeJson.trajectory.length === 8) 
    ? narrativeJson.trajectory.map((t: any) => ({
        horizonMonths: t.horizonMonths as 3 | 6 | 9 | 12,
        lane: t.lane as "without_plan" | "with_plan",
        title: t.title || "",
        description: t.description || "",
        confidence: (t.confidence === "LOW" || t.confidence === "MED" || t.confidence === "HIGH") 
          ? t.confidence 
          : "MED" as const,
        drivers: Array.isArray(t.drivers) 
          ? t.drivers.map((d: any) => ({
              metricId: d.metricId || "",
              driverTag: d.driverTag || "",
            }))
          : [], // Use LLM-generated drivers if available
      }))
    : trajectoryPoints; // Fallback to deterministic if LLM didn't provide valid trajectory

  return validateNarrative(narrativeJson, finalTrajectory);
}






